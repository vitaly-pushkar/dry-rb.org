<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta content="phone" media="(max-width: 480px)" name="breakpoint" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><link href="/feed.xml" rel="alternate" title="dry-rb news" type="application/atom+xml" /><link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:400,400i,600,600i" rel="stylesheet" /><link href="/images/favicon-651cfa16.png" rel="icon" /><!--[if IE]><link href="/images/favicon.ico" rel="shortcut icon" /><![endif]--><title>dry-rb - dry-view 0.6.0, an introductory talk, and plans for 1.0</title><link href="/assets/stylesheets/site-c3c49dd8.css" rel="stylesheet" /><script src="/assets/javascripts/site-77c35e63.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-2573270-8', 'auto');
ga('send', 'pageview');</script></head><body><header><div class="content-wrap"><nav class="main-nav"><ul class="main-nav__list"><li class="main-nav__logo"><a href="/">dry-rb</a></li><li class="main-nav__with-dropdown"><a href="/gems">Gems <span class="hide-mobile">/ Docs </span></a><div class="main-nav__dropdown main-nav__dropdown--gems"><ul><li></li><a href="/gems/dry-auto_inject/">dry-auto_inject</a><li></li><a href="/gems/dry-configurable/">dry-configurable</a><li></li><a href="/gems/dry-container/">dry-container</a><li></li><a href="/gems/dry-core/">dry-core</a><li></li><a href="/gems/dry-equalizer/">dry-equalizer</a><li></li><a href="/gems/dry-events/">dry-events</a><li></li><a href="/gems/dry-inflector/">dry-inflector</a><li></li><a href="/gems/dry-initializer/">dry-initializer</a><li></li><a href="/gems/dry-logic/">dry-logic</a></ul><ul><li></li><a href="/gems/dry-matcher/">dry-matcher</a><li></li><a href="/gems/dry-monads/1.0">dry-monads</a><li></li><a href="/gems/dry-schema/">dry-schema</a><li></li><a href="/gems/dry-struct/">dry-struct</a><li></li><a href="/gems/dry-system/">dry-system</a><li></li><a href="/gems/dry-transaction/">dry-transaction</a><li></li><a href="/gems/dry-types/">dry-types</a><li></li><a href="/gems/dry-validation/0.13">dry-validation</a><li></li><a href="/gems/dry-view/">dry-view</a></ul></div></li><li><a href="/status">Status</a></li><li class="main-nav__item--selected"><a href="/news">News</a></li><li><a href="/community">Community</a></li><li class="main-nav__code"><a href="https://github.com/dry-rb">Github</a></li></ul></nav></div></header><div class="intro-page intro-page--content"><div class="content-wrap"><div class="intro-page__inner"><h1>dry-view 0.6.0, an introductory talk, and plans for 1.0</h1><div class="news-article-meta">Published on February 12, 2019 by <a href="https://twitter.com/timriley">Tim Riley</a></div></div></div></div><div class="row"><div class="content-wrap"><article class="news-article"><p>Last month we released <a href="/gems/dry-view/">dry-view</a> 0.6.0, a very special release that made huge strides towards the system&rsquo;s overall completeness. With 0.6.0, dry-view should now offer <em>everything you need</em> to write better organized views in Ruby.</p>

<p>From here, our goal is to take dry-view to version 1.0. So please give this release a try! Your feedback at this point will help ensure 1.0 is as polished as possible.</p>

<p>If you&rsquo;re new to dry-view, or would like to see its new features presented in context, then you&rsquo;re in luck! <a href="https://youtu.be/VGWt1OLFzdU">My talk from RubyConf AU</a> (which took place just last week!) is a nice and tidy, 20-minute package explaining dry-view&rsquo;s rationale and how everything fits together:</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/VGWt1OLFzdU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>I&rsquo;d also invite you to take another look at the <a href="/gems/dry-view/">dry-view documentation</a>. This has been brought up to date and covers all the new features.</p>

<p>And as for what’s changed with this release, here are the highlights:</p>

<h2 id="letting-views-be-views">Letting views be views</h2>

<p>Firstly, a simple change, but a meaningful one: <code>Dry::View::Controller</code> has been renamed to <code>Dry::View</code>.</p>

<p>Until now, we gave the name &ldquo;view controllers&rdquo; to our main view objects. This felt reasonable, since their job was very much about <em>coordination</em> - holding configuration, accepting input data, then working with other parts of the application to prepare values for its template.</p>

<p>However, this was always a source of confusion: view controllers may be an established pattern in other languages and frameworks, but not within Ruby, where the term &ldquo;controller&rdquo; is firmly entrenched as an object for handling HTTP requests.</p>

<p>And even with the previous name, we&rsquo;d still end up calling these things &ldquo;views&rdquo; once we started using them within an application. So we&rsquo;ve paved the cow path and embraced <code>Dry::View</code> as the name for these view classes. Let views be views.</p>

<h2 id="automatic-part-decoration">Automatic part decoration</h2>

<p><a href="/gems/dry-view/parts/">Parts</a> are a major reason to use dry-view: they offer an easy, integrated place for encapsulating view-specific behaviour alongside the data it relates to.</p>

<p>Until now, however, using a broad range of part classes involved specifying those classes by name, directly, for every exposure.</p>

<p>With this release, dry-view&rsquo;s standard part builder comes with automatic part class resolution. Now you can configure a <code>part_namespace</code> on your view class, and then your exposure values will automatically be decorated by matching parts found within that namespace.</p>

<p>An example will speak a thousand words:</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="k">module</span> <span class="nn">Parts</span>
  <span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">Dry</span><span class="o">::</span><span class="no">View</span><span class="o">::</span><span class="no">Part</span>
  <span class="k">end</span>
  <span class="k">class</span> <span class="nc">Author</span> <span class="o">&lt;</span> <span class="no">Dry</span><span class="o">::</span><span class="no">View</span><span class="o">::</span><span class="no">Part</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">AuthorContributionsView</span> <span class="o">&lt;</span> <span class="no">Dry</span><span class="o">::</span><span class="no">View</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">part_namespace</span> <span class="o">=</span> <span class="no">Parts</span>

  <span class="n">expose</span> <span class="ss">:author</span>   <span class="c1"># decorated by Parts::Author</span>
  <span class="n">expose</span> <span class="ss">:articles</span> <span class="c1"># each item decorated by Parts::Article</span>
<span class="k">end</span>
</code></pre></div>
<p>Part decoration of exposure values can still be customized using the <code>:as</code> option, which now accepts both a concrete part class, as well as a symbolic name (e.g. <code>expose :admin_user, as: :user</code>), which will become the name used for the automatic part class resolution.</p>

<p>If you don&rsquo;t want an exposure value to be decorated, you can provide the <code>decorate: false</code> option. This can be useful when exposing &ldquo;primitive&rdquo; values (e.g. strings or numbers, etc.) instead of richer domain objects or data structures.</p>

<h2 id="increased-access-to-parts">Increased access to parts</h2>

<p>Part behavior is now available when exposures access each other via exposure dependencies:</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">AuthorContributionsView</span> <span class="o">&lt;</span> <span class="no">Dry</span><span class="o">::</span><span class="no">View</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">part_namespace</span> <span class="o">=</span> <span class="no">Parts</span>

  <span class="n">expose</span> <span class="ss">:author</span>

  <span class="n">expose</span> <span class="ss">:articles</span> <span class="k">do</span> <span class="o">|</span><span class="n">author</span><span class="o">|</span>
      <span class="c1"># author is a `Parts::Author` here</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Along with this, parts can now be accessed via a new <code>Dry::View::Rendered</code> object that is returned when calling views. This object converts to a string to return the view output (<code>my_view.call.to_s</code>), but also carries all the parts that are exposed to the template, which are accessible by name (<code>my_view.call[:author]</code>) and also as a complete hash of locals (<code>my_view.call.locals</code>).</p>

<h2 id="customizable-scopes">Customizable scopes!</h2>

<p>Until now, we’ve had exposures and parts to pass values to the template along with their view-specific behavior, and the context object to provide behavior common to all templates. But what about behavior that we want to provide to just a <em>single</em> template or partial?For this, we now have <a href="/gems/dry-view/scopes/">customizable scopes</a>.</p>

<p>Unlike parts, which decorate a single value, scopes have access to a template’s entire set of locals (as well as the context object, plus the methods to render partial or build other scopes). This gives you another logical place to provide some custom view behavior that can still access all the other features of the system.</p>

<p>Scopes must inherit from <code>Dry::View::Scope</code>. Locals can be accessed via their names, and the full hash is available via <code>#locals</code>. Other methods of interest are <code>#context</code>, <code>#render</code>, and <code>#scope</code>.</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="k">module</span> <span class="nn">Scopes</span>
  <span class="k">class</span> <span class="nc">MediaPlayer</span> <span class="o">&lt;</span> <span class="no">Dry</span><span class="o">::</span><span class="no">View</span><span class="o">::</span><span class="no">Scope</span>
    <span class="k">def</span> <span class="nf">show_buttons?</span>
      <span class="c1"># Referencing full `locals` hash</span>
      <span class="n">locals</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="ss">:show_buttons</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">player_title</span>
      <span class="c1"># Referencing `item` local</span>
      <span class="s2">"Media player: </span><span class="si">#{</span><span class="n">item</span><span class="p">.</span><span class="nf">title</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>You can specify a scope to use for a view’s own template:</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">MyView</span> <span class="o">&lt;</span> <span class="no">Dry</span><span class="o">::</span><span class="no">View</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">template</span> <span class="o">=</span> <span class="s2">"my_template"</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">scope</span> <span class="o">=</span> <span class="no">MyScope</span>
<span class="k">end</span>
</code></pre></div>
<p>You can also build specify a <code>scope_namespace</code> which will be used to search for scopes when you build them up <em>inside a template</em>:</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">MyView</span> <span class="o">&lt;</span> <span class="no">Dry</span><span class="o">::</span><span class="no">View</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">template</span> <span class="o">=</span> <span class="s2">"my_template"</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">scope_namespace</span> <span class="o">=</span> <span class="no">Scopes</span>
<span class="k">end</span>
</code></pre></div><div class="highlight"><pre class="syntax erb"><code><span class="nt">&lt;h1&gt;</span>My multimedia<span class="nt">&lt;/h1&gt;</span>

<span class="c">&lt;!-- Builds Scopes::MediaPlayer and renders its partial --&gt;</span>
<span class="cp">&lt;%=</span> <span class="n">scope</span><span class="p">(</span><span class="ss">:media_player</span><span class="p">,</span> <span class="ss">item: </span><span class="n">item</span><span class="p">).</span><span class="nf">render</span> <span class="cp">%&gt;</span>
</code></pre></div>
<p>Rendering a scope like this will look for a partial matching the scope’s own name (in this case <code>_media_player.html.erb</code>), which can make for some quite expressive uses of inline scopes. Of course, you can continue to render partials with explicitly provided names, both externally, like within this template, or inside methods you define in your custom scope classes.</p>

<h2 id="context-object-can-decorate-attributes">Context object can decorate attributes</h2>

<p><a href="/gems/dry-view/context">Context</a> classes must now inherit from <code>Dry::View::Context</code>. This brings the ability for context classes to specify which of their attributes should be decorated with parts.</p>

<p>For example, for a context with an injected <code>assets</code> dependency, specifying <code>decorate :assets</code> would have the assets object wrapped in a matching part class (e.g. <code>Parts::Assets</code> if the view currently rendering has a <code>part_namespace</code> of <code>Parts</code>).</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">Context</span> <span class="o">&lt;</span> <span class="no">Dry</span><span class="o">::</span><span class="no">View</span><span class="o">::</span><span class="no">Context</span>
  <span class="nb">attr_reader</span> <span class="ss">:assets</span>
  <span class="n">decorate</span> <span class="ss">:assets</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">assets</span><span class="p">:,</span> <span class="o">**</span><span class="p">)</span>
    <span class="vi">@assets</span> <span class="o">=</span> <span class="n">assets</span>
    <span class="k">super</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<h2 id="exposure-blocks-methods-can-access-context">Exposure blocks/methods can access context</h2>

<p>A key theme of dry-view is making every aspect of the view rendering facilities available to every component of the system. In this vein, the context object is now accessible from exposure blocks and methods, via specifying a <code>context:</code> parameter.</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="k">class</span> <span class="nc">AuthorContributionsView</span> <span class="o">&lt;</span> <span class="no">Dry</span><span class="o">::</span><span class="no">View</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">part_namespace</span> <span class="o">=</span> <span class="no">Parts</span>

  <span class="n">expose</span> <span class="ss">:author</span> <span class="k">do</span> <span class="o">|</span><span class="n">author_id</span><span class="p">:,</span> <span class="n">context</span><span class="ss">:|</span>
    <span class="c1"># author_id comes from the view's `#call` args</span>

    <span class="c1"># context is either:</span>
    <span class="c1">#  - or context provided to `#call`</span>
    <span class="c1">#  - or the view's configured default context</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<h2 id="layout-exposures">Layout exposures</h2>

<p>Exposures can now be sent to the layout via the <code>layout: true</code> option.</p>

<h2 id="full-support-for-erb-haml">Full support for Erb &amp; Haml</h2>

<p>An important aspect of template authoring with dry-view is the ability to pass blocks to any method or partial from within a template, and have these behave as you&rsquo;d expect (i.e with the <code>yield</code> inside the method or partial returning the evaluated contents of the block).</p>

<p>This has always worked out of the box with <a href="http://slim-lang.com">Slim templates</a>, which will serve us for a quick example. Say we have a <code>_wrapper.html.slim</code> partial:</p>
<div class="highlight"><pre class="syntax slim"><code><span class="nc">.wrapper</span>
  <span class="p">==</span> <span class="k">yield</span>
</code></pre></div>
<p>Then rendering this partial in a template like so:</p>
<div class="highlight"><pre class="syntax slim"><code><span class="p">==</span> <span class="n">render</span><span class="p">(</span><span class="ss">:wrapper</span><span class="p">)</span> <span class="k">do</span>
  <span class="nt">p</span><span class="w"> </span>Hello<span class="w"> </span>there!
</code></pre></div>
<p>Will give us output like this:</p>
<div class="highlight"><pre class="syntax html"><code><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"wrapper"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;p&gt;</span>Hello there!<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div>
<p>Makes sense, right? Turns out this isn’t possible with the other popular Ruby templating languages, Erb and Haml, without some huge degree of hackery. Luckily for us, there are 2 alternative implementations of these languages that support this sensible block capturing, <a href="https://github.com/apotonick/erbse">erbse</a> and <a href="https://github.com/hamlit/hamlit-block">hamlit-block</a> respectively. To give dry-view full Erb and Haml support, it will now require one of these gems to be installed before attempting to render an Erb or Haml template.</p>

<h2 id="easier-unit-testing-for-parts-and-scopes">Easier unit testing for Parts and Scopes</h2>

<p>Parts and scopes can now be more easily <a href="/gems/dry-view/testing/">unit tested</a>.</p>

<p>If you want to unit test the aspects of the class that don’t require a full rendering environment, you can now instantiate a Part with its value alone:</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="n">part_for_testing</span> <span class="o">=</span> <span class="no">Parts</span><span class="o">::</span><span class="no">Article</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">value: </span><span class="n">my_article</span><span class="p">)</span>
</code></pre></div>
<p>If you want to unit test aspects of a part that do require a full rendering environment, like rendering partials or accessing the context object, then you can now build a <code>template_env</code> off an existing view class:</p>
<div class="highlight"><pre class="syntax ruby"><code><span class="n">part_for_testing</span> <span class="o">=</span> <span class="no">Parts</span><span class="o">::</span><span class="no">Article</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="ss">name: :article</span><span class="p">,</span>
  <span class="ss">value: </span><span class="n">my_article</span><span class="p">,</span>
  <span class="ss">render_env: </span><span class="no">MyView</span><span class="p">.</span><span class="nf">template_env</span><span class="p">,</span>
<span class="p">)</span>
</code></pre></div>
<p>For more detailed unit testing examples, see the <a href="/gems/dry-view/testing/">dry-view testing documentation</a>.</p>

<h2 id="and-more">And more!</h2>

<p>Phew! Those were just the highlights. For more, see the <a href="https://github.com/dry-rb/dry-view/releases/tag/v0.6.0">detailed release notes</a> for 0.6.0.</p>
</article></div></div><footer><div class="content-wrap"><nav class="footer__links"><ul><li><a href="/gems"><span>Gems</span></a></li><li><a href="/community"><span>Community</span></a></li><li><a href="https://github.com/dry-rb"><span>Code</span></a></li><li><a href="https://discourse.dry-rb.org"><span>Discussion</span></a></li><li><a href="https://dry-rb.zulipchat.com"><span>Chat</span></a></li><li><a href="https://twitter.com/dry_rb"><span>Twitter</span></a></li></ul></nav><div class="footer__credits"><p>Website made with love by <a href="https://www.icelab.com.au/">Icelab</a>.</p></div></div></footer></body></html>